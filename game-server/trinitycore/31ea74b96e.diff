diff --git a/dep/CMakeLists.txt b/dep/CMakeLists.txt
index 9c1b5cd9b9..16ab74f444 100644
--- a/dep/CMakeLists.txt
+++ b/dep/CMakeLists.txt
@@ -36,6 +36,8 @@ if(TOOLS)
   add_subdirectory(libmpq)
 endif()
 
+add_subdirectory(libsidecar)
+
 if(BUILD_TESTING)
   include(FetchContent)
   FetchContent_Declare(Catch2
diff --git a/dep/PackageList.txt b/dep/PackageList.txt
index bb696a237d..59f5779a8a 100644
--- a/dep/PackageList.txt
+++ b/dep/PackageList.txt
@@ -72,3 +72,5 @@ argon2
 catch2
   https://github.com/catchorg/Catch2
   Version: v2.13.0
+
+sidecar
diff --git a/dep/libsidecar/CMakeLists.txt b/dep/libsidecar/CMakeLists.txt
new file mode 100644
index 0000000000..dc8fb1c1a0
--- /dev/null
+++ b/dep/libsidecar/CMakeLists.txt
@@ -0,0 +1,8 @@
+add_library(sidecar SHARED IMPORTED GLOBAL)
+
+set_target_properties(sidecar
+  PROPERTIES
+    IMPORTED_LOCATION
+      ${CMAKE_CURRENT_SOURCE_DIR}/libsidecar.dylib
+    INTERFACE_INCLUDE_DIRECTORIES
+      ${CMAKE_CURRENT_SOURCE_DIR}/include)
diff --git a/dep/libsidecar/include/libsidecar.h b/dep/libsidecar/include/libsidecar.h
new file mode 100644
index 0000000000..d1bf42038e
--- /dev/null
+++ b/dep/libsidecar/include/libsidecar.h
@@ -0,0 +1,75 @@
+/* Code generated by cmd/cgo; DO NOT EDIT. */
+
+/* package command-line-arguments */
+
+
+#line 1 "cgo-builtin-export-prolog"
+
+#include <stddef.h> /* for ptrdiff_t below */
+
+#ifndef GO_CGO_EXPORT_PROLOGUE_H
+#define GO_CGO_EXPORT_PROLOGUE_H
+
+#ifndef GO_CGO_GOSTRING_TYPEDEF
+typedef struct { const char *p; ptrdiff_t n; } _GoString_;
+#endif
+
+#endif
+
+/* Start of preamble from import "C" comments.  */
+
+
+
+
+/* End of preamble from import "C" comments.  */
+
+
+/* Start of boilerplate cgo prologue.  */
+#line 1 "cgo-gcc-export-header-prolog"
+
+#ifndef GO_CGO_PROLOGUE_H
+#define GO_CGO_PROLOGUE_H
+
+typedef signed char GoInt8;
+typedef unsigned char GoUint8;
+typedef short GoInt16;
+typedef unsigned short GoUint16;
+typedef int GoInt32;
+typedef unsigned int GoUint32;
+typedef long long GoInt64;
+typedef unsigned long long GoUint64;
+typedef GoInt64 GoInt;
+typedef GoUint64 GoUint;
+typedef __SIZE_TYPE__ GoUintptr;
+typedef float GoFloat32;
+typedef double GoFloat64;
+typedef float _Complex GoComplex64;
+typedef double _Complex GoComplex128;
+
+/*
+  static assertion to make sure the file is being used on architecture
+  at least with matching size of GoInt.
+*/
+typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];
+
+#ifndef GO_CGO_GOSTRING_TYPEDEF
+typedef _GoString_ GoString;
+#endif
+typedef void *GoMap;
+typedef void *GoChan;
+typedef struct { void *t; void *v; } GoInterface;
+typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;
+
+#endif
+
+/* End of boilerplate cgo prologue.  */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern void AddToRegistry(GoUint16 port, GoUint32 realmID, char* availableMaps);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index 5fa661038f..32d85e4bbc 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -713,12 +713,13 @@ void WorldSession::HandlePlayerLoginOpcode(WorldPacket& recvData)
 
     recvData >> playerGuid;
 
-    if (!IsLegitCharacterForAccount(playerGuid))
-    {
-        TC_LOG_ERROR("network", "Account (%u) can't login with that character (%s).", GetAccountId(), playerGuid.ToString().c_str());
-        KickPlayer("WorldSession::HandlePlayerLoginOpcode Trying to login with a character of another account");
-        return;
-    }
+//    if (!IsLegitCharacterForAccount(playerGuid))
+//    {
+//        ObjectGuid guid(HighGuid::Player, (uint32)(1));
+//        TC_LOG_ERROR("network", "Account (%u) can't login with that character (%s). %lld", GetAccountId(), playerGuid.ToString().c_str(), guid.GetRawValue());
+//        KickPlayer("WorldSession::HandlePlayerLoginOpcode Trying to login with a character of another account");
+//        return;
+//    }
 
     std::shared_ptr<LoginQueryHolder> holder = std::make_shared<LoginQueryHolder>(GetAccountId(), playerGuid);
     if (!holder->Initialize())
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index a03fdb9675..c42481e1df 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -1317,17 +1317,17 @@ void WorldSession::InitializeSessionCallback(CharacterDatabaseQueryHolder const&
     LoadAccountData(realmHolder.GetPreparedResult(AccountInfoQueryHolderPerRealm::GLOBAL_ACCOUNT_DATA), GLOBAL_CACHE_MASK);
     LoadTutorialsData(realmHolder.GetPreparedResult(AccountInfoQueryHolderPerRealm::TUTORIALS));
 
-    if (!m_inQueue)
-        SendAuthResponse(AUTH_OK, true);
-    else
-        SendAuthWaitQueue(0);
+    // if (!m_inQueue)
+    //     SendAuthResponse(AUTH_OK, true);
+    // else
+    //     SendAuthWaitQueue(0);
 
     SetInQueue(false);
     ResetTimeOutTime(false);
 
-    SendAddonsInfo();
-    SendClientCacheVersion(sWorld->getIntConfig(CONFIG_CLIENTCACHE_VERSION));
-    SendTutorialsData();
+    // SendAddonsInfo();
+    // SendClientCacheVersion(sWorld->getIntConfig(CONFIG_CLIENTCACHE_VERSION));
+    // SendTutorialsData();
 }
 
 rbac::RBACData* WorldSession::GetRBACData()
diff --git a/src/server/game/Server/WorldSocket.cpp b/src/server/game/Server/WorldSocket.cpp
index 9dd2751579..35747f7ed8 100644
--- a/src/server/game/Server/WorldSocket.cpp
+++ b/src/server/game/Server/WorldSocket.cpp
@@ -75,7 +75,7 @@ void WorldSocket::CheckIpCallback(PreparedQueryResult result)
     }
 
     AsyncRead();
-    HandleSendAuthSession();
+//    HandleSendAuthSession();
 }
 
 bool WorldSocket::Update()
@@ -303,6 +303,8 @@ WorldSocket::ReadDataHandlerResult WorldSocket::ReadDataHandler()
     if (sPacketLog->CanLogPacket())
         sPacketLog->LogPacket(packet, CLIENT_TO_SERVER, GetRemoteIpAddress(), GetRemotePort());
 
+    TC_LOG_ERROR("network", "Received packet %d(0x%X) %s", header->cmd, header->cmd, GetOpcodeNameForLogging(static_cast<OpcodeClient>(header->cmd)).c_str());
+
     std::unique_lock<std::mutex> sessionGuard(_worldSessionLock, std::defer_lock);
 
     switch (opcode)
@@ -472,7 +474,7 @@ void WorldSocket::HandleAuthSessionCallback(std::shared_ptr<AuthSession> authSes
     }
 
     // even if auth credentials are bad, try using the session key we have - client cannot read auth response error without it
-    _authCrypt.Init(account.SessionKey);
+//    _authCrypt.Init(account.SessionKey);
 
     // First reject the connection if packet contains invalid data or realm state doesn't allow logging in
     if (sWorld->IsClosed())
@@ -492,15 +494,15 @@ void WorldSocket::HandleAuthSessionCallback(std::shared_ptr<AuthSession> authSes
         return;
     }
 
-    // Must be done before WorldSession is created
-    bool wardenActive = sWorld->getBoolConfig(CONFIG_WARDEN_ENABLED);
-    if (wardenActive && account.OS != "Win" && account.OS != "OSX")
-    {
-        SendAuthResponseError(AUTH_REJECT);
-        TC_LOG_ERROR("network", "WorldSocket::HandleAuthSession: Client %s attempted to log in using invalid client OS (%s).", address.c_str(), account.OS.c_str());
-        DelayedCloseSocket();
-        return;
-    }
+//    // Must be done before WorldSession is created
+//    bool wardenActive = sWorld->getBoolConfig(CONFIG_WARDEN_ENABLED);
+//    if (wardenActive && account.OS != "Win" && account.OS != "OSX")
+//    {
+//        SendAuthResponseError(AUTH_REJECT);
+//        TC_LOG_ERROR("network", "WorldSocket::HandleAuthSession: Client %s attempted to log in using invalid client OS (%s).", address.c_str(), account.OS.c_str());
+//        DelayedCloseSocket();
+//        return;
+//    }
 
     // Check that Key and account name are the same on client and server
     uint8 t[4] = { 0x00,0x00,0x00,0x00 };
@@ -512,43 +514,43 @@ void WorldSocket::HandleAuthSessionCallback(std::shared_ptr<AuthSession> authSes
     sha.UpdateData(_authSeed);
     sha.UpdateData(account.SessionKey);
     sha.Finalize();
-
-    if (sha.GetDigest() != authSession->Digest)
-    {
-        SendAuthResponseError(AUTH_FAILED);
-        TC_LOG_ERROR("network", "WorldSocket::HandleAuthSession: Authentication failed for account: %u ('%s') address: %s", account.Id, authSession->Account.c_str(), address.c_str());
-        DelayedCloseSocket();
-        return;
-    }
-
-    if (IpLocationRecord const* location = sIPLocation->GetLocationRecord(address))
-        _ipCountry = location->CountryCode;
-
-    ///- Re-check ip locking (same check as in auth).
-    if (account.IsLockedToIP)
-    {
-        if (account.LastIP != address)
-        {
-            SendAuthResponseError(AUTH_FAILED);
-            TC_LOG_DEBUG("network", "WorldSocket::HandleAuthSession: Sent Auth Response (Account IP differs. Original IP: %s, new IP: %s).", account.LastIP.c_str(), address.c_str());
-            // We could log on hook only instead of an additional db log, however action logger is config based. Better keep DB logging as well
-            sScriptMgr->OnFailedAccountLogin(account.Id);
-            DelayedCloseSocket();
-            return;
-        }
-    }
-    else if (!account.LockCountry.empty() && account.LockCountry != "00" && !_ipCountry.empty())
-    {
-        if (account.LockCountry != _ipCountry)
-        {
-            SendAuthResponseError(AUTH_FAILED);
-            TC_LOG_DEBUG("network", "WorldSocket::HandleAuthSession: Sent Auth Response (Account country differs. Original country: %s, new country: %s).", account.LockCountry.c_str(), _ipCountry.c_str());
-            // We could log on hook only instead of an additional db log, however action logger is config based. Better keep DB logging as well
-            sScriptMgr->OnFailedAccountLogin(account.Id);
-            DelayedCloseSocket();
-            return;
-        }
-    }
+//
+//    if (sha.GetDigest() != authSession->Digest)
+//    {
+//        SendAuthResponseError(AUTH_FAILED);
+//        TC_LOG_ERROR("network", "WorldSocket::HandleAuthSession: Authentication failed for account: %u ('%s') address: %s", account.Id, authSession->Account.c_str(), address.c_str());
+//        DelayedCloseSocket();
+//        return;
+//    }
+//
+//    if (IpLocationRecord const* location = sIPLocation->GetLocationRecord(address))
+//        _ipCountry = location->CountryCode;
+//
+//    ///- Re-check ip locking (same check as in auth).
+//    if (account.IsLockedToIP)
+//    {
+//        if (account.LastIP != address)
+//        {
+//            SendAuthResponseError(AUTH_FAILED);
+//            TC_LOG_DEBUG("network", "WorldSocket::HandleAuthSession: Sent Auth Response (Account IP differs. Original IP: %s, new IP: %s).", account.LastIP.c_str(), address.c_str());
+//            // We could log on hook only instead of an additional db log, however action logger is config based. Better keep DB logging as well
+//            sScriptMgr->OnFailedAccountLogin(account.Id);
+//            DelayedCloseSocket();
+//            return;
+//        }
+//    }
+//    else if (!account.LockCountry.empty() && account.LockCountry != "00" && !_ipCountry.empty())
+//    {
+//        if (account.LockCountry != _ipCountry)
+//        {
+//            SendAuthResponseError(AUTH_FAILED);
+//            TC_LOG_DEBUG("network", "WorldSocket::HandleAuthSession: Sent Auth Response (Account country differs. Original country: %s, new country: %s).", account.LockCountry.c_str(), _ipCountry.c_str());
+//            // We could log on hook only instead of an additional db log, however action logger is config based. Better keep DB logging as well
+//            sScriptMgr->OnFailedAccountLogin(account.Id);
+//            DelayedCloseSocket();
+//            return;
+//        }
+//    }
 
     int64 mutetime = account.MuteTime;
     //! Negative mutetime indicates amount of seconds to be muted effective on next login - which is now.
@@ -605,8 +607,8 @@ void WorldSocket::HandleAuthSessionCallback(std::shared_ptr<AuthSession> authSes
     _worldSession->ReadAddonsInfo(authSession->AddonInfo);
 
     // Initialize Warden system only if it is enabled by config
-    if (wardenActive)
-        _worldSession->InitWarden(account.SessionKey, account.OS);
+//    if (wardenActive)
+//        _worldSession->InitWarden(account.SessionKey, account.OS);
 
     _queryProcessor.AddCallback(_worldSession->LoadPermissionsAsync().WithPreparedCallback(std::bind(&WorldSocket::LoadSessionPermissionsCallback, this, std::placeholders::_1)));
     AsyncRead();
diff --git a/src/server/worldserver/CMakeLists.txt b/src/server/worldserver/CMakeLists.txt
index f67a7a5b7f..df4ccd6dcd 100644
--- a/src/server/worldserver/CMakeLists.txt
+++ b/src/server/worldserver/CMakeLists.txt
@@ -51,7 +51,8 @@ target_link_libraries(worldserver
     scripts
     game
     gsoap
-    readline)
+    readline
+    sidecar)
 
 CollectIncludeDirectories(
   ${CMAKE_CURRENT_SOURCE_DIR}
diff --git a/src/server/worldserver/Main.cpp b/src/server/worldserver/Main.cpp
index 418b5de5eb..bf7ebc6935 100644
--- a/src/server/worldserver/Main.cpp
+++ b/src/server/worldserver/Main.cpp
@@ -59,6 +59,7 @@
 #include <boost/program_options.hpp>
 #include <csignal>
 #include <iostream>
+#include "libsidecar.h"
 
 using namespace boost::program_options;
 namespace fs = boost::filesystem;
@@ -145,7 +146,7 @@ extern int main(int argc, char** argv)
         printf("Error in config file: %s\n", configError.c_str());
         return 1;
     }
-
+    
     std::vector<std::string> overriddenKeys = sConfigMgr->OverrideWithEnvVariablesIfAny();
 
     std::shared_ptr<Trinity::Asio::IoContext> ioContext = std::make_shared<Trinity::Asio::IoContext>();
@@ -166,7 +167,7 @@ extern int main(int argc, char** argv)
             TC_LOG_INFO("server.worldserver", "Using Boost version: %i.%i.%i", BOOST_VERSION / 100000, BOOST_VERSION / 100 % 1000, BOOST_VERSION % 100);
         }
     );
-
+    
     for (std::string const& key : overriddenKeys)
         TC_LOG_INFO("server.worldserver", "Configuration field '%s' was overridden with environment variable.", key.c_str());
 
@@ -346,6 +347,11 @@ extern int main(int argc, char** argv)
     {
         cliThread.reset(new std::thread(CliThread), &ShutdownCLIThread);
     }
+    
+    std::string availableMaps = "";
+    char *avaialbeMapsCStr = new char[availableMaps.length()+1];
+    
+    AddToRegistry(worldPort, realm.Id.Realm, avaialbeMapsCStr);
 
     WorldUpdateLoop();
 
